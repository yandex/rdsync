diff --git a/.gitignore b/.gitignore
index d85087c45..39a257625 100644
--- a/.gitignore
+++ b/.gitignore
@@ -12,6 +12,7 @@ dump*.rdb
 *-check-dump
 *-cli
 *-sentinel
+*-senticache
 *-server
 *-unit-tests
 doc-tools
diff --git a/runtest-senticache b/runtest-senticache
new file mode 100755
index 000000000..ce860dc43
--- /dev/null
+++ b/runtest-senticache
@@ -0,0 +1,14 @@
+#!/bin/sh
+TCL_VERSIONS="8.5 8.6 8.7"
+TCLSH=""
+
+for VERSION in $TCL_VERSIONS; do
+	TCL=`which tclsh$VERSION 2>/dev/null` && TCLSH=$TCL
+done
+
+if [ -z $TCLSH ]
+then
+    echo "You need tcl 8.5 or newer in order to run the Redis Senticache test"
+    exit 1
+fi
+$TCLSH tests/senticache/run.tcl $*
diff --git a/senticache.conf b/senticache.conf
new file mode 100644
index 000000000..5e922cd9f
--- /dev/null
+++ b/senticache.conf
@@ -0,0 +1,9 @@
+protected-mode no
+port 26379
+daemonize no
+pidfile "./valkey-senticache.pid"
+logfile ""
+dir "/tmp"
+acllog-max-len 128
+sentinel resolve-hostnames no
+sentinel announce-hostnames no
diff --git a/src/Makefile b/src/Makefile
index 1437f41bd..4b736b340 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -416,7 +416,9 @@ endif
 ENGINE_NAME=valkey
 SERVER_NAME=$(ENGINE_NAME)-server$(PROG_SUFFIX)
 ENGINE_SENTINEL_NAME=$(ENGINE_NAME)-sentinel$(PROG_SUFFIX)
+ENGINE_SENTICACHE_NAME=$(ENGINE_NAME)-senticache$(PROG_SUFFIX)
 ENGINE_SERVER_OBJ=threads_mngr.o adlist.o quicklist.o ae.o anet.o dict.o hashtable.o kvstore.o server.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o ziplist.o release.o memory_prefetch.o io_threads.o networking.o util.o object.o db.o replication.o rdb.o t_string.o t_list.o t_set.o t_zset.o t_hash.o config.o aof.o pubsub.o multi.o debug.o sort.o intset.o syncio.o cluster.o cluster_legacy.o cluster_slot_stats.o crc16.o endianconv.o commandlog.o eval.o bio.o rio.o rand.o memtest.o syscheck.o crcspeed.o crccombine.o crc64.o bitops.o sentinel.o notify.o setproctitle.o blocked.o hyperloglog.o latency.o sparkline.o valkey-check-rdb.o valkey-check-aof.o geo.o lazyfree.o module.o evict.o expire.o geohash.o geohash_helper.o childinfo.o allocator_defrag.o defrag.o siphash.o rax.o t_stream.o listpack.o localtime.o lolwut.o lolwut5.o lolwut6.o acl.o tracking.o socket.o tls.o sha256.o timeout.o setcpuaffinity.o monotonic.o mt19937-64.o resp_parser.o call_reply.o script.o functions.o commands.o strl.o connection.o unix.o logreqres.o rdma.o scripting_engine.o lua/script_lua.o lua/function_lua.o lua/engine_lua.o lua/debug_lua.o
+ENGINE_SENTICACHE_OBJ=threads_mngr.o adlist.o quicklist.o ae.o anet.o dict.o hashtable.o kvstore.o server.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o ziplist.o release.o memory_prefetch.o io_threads.o networking.o util.o object.o db.o replication.o rdb.o t_string.o t_list.o t_set.o t_zset.o t_hash.o config.o aof.o pubsub.o multi.o debug.o sort.o intset.o syncio.o cluster.o cluster_legacy.o cluster_slot_stats.o crc16.o endianconv.o commandlog.o eval.o bio.o rio.o rand.o memtest.o syscheck.o crcspeed.o crccombine.o crc64.o bitops.o senticache.o notify.o setproctitle.o blocked.o hyperloglog.o latency.o sparkline.o valkey-check-rdb.o valkey-check-aof.o geo.o lazyfree.o module.o evict.o expire.o geohash.o geohash_helper.o childinfo.o allocator_defrag.o defrag.o siphash.o rax.o t_stream.o listpack.o localtime.o lolwut.o lolwut5.o lolwut6.o acl.o tracking.o socket.o tls.o sha256.o timeout.o setcpuaffinity.o monotonic.o mt19937-64.o resp_parser.o call_reply.o script.o functions.o commands.o strl.o connection.o unix.o logreqres.o rdma.o scripting_engine.o lua/script_lua.o lua/function_lua.o lua/engine_lua.o lua/debug_lua.o
 ENGINE_CLI_NAME=$(ENGINE_NAME)-cli$(PROG_SUFFIX)
 ENGINE_CLI_OBJ=anet.o adlist.o dict.o valkey-cli.o zmalloc.o release.o ae.o serverassert.o crcspeed.o crccombine.o crc64.o siphash.o crc16.o monotonic.o cli_common.o mt19937-64.o strl.o cli_commands.o
 ENGINE_BENCHMARK_NAME=$(ENGINE_NAME)-benchmark$(PROG_SUFFIX)
@@ -440,7 +442,7 @@ ifeq ($(USE_FAST_FLOAT),yes)
 	FINAL_LIBS += $(FAST_FLOAT_STRTOD_OBJECT)
 endif
 
-all: $(SERVER_NAME) $(ENGINE_SENTINEL_NAME) $(ENGINE_CLI_NAME) $(ENGINE_BENCHMARK_NAME) $(ENGINE_CHECK_RDB_NAME) $(ENGINE_CHECK_AOF_NAME) $(TLS_MODULE) $(RDMA_MODULE)
+all: $(SERVER_NAME) $(ENGINE_SENTINEL_NAME) $(ENGINE_SENTICACHE_NAME) $(ENGINE_CLI_NAME) $(ENGINE_BENCHMARK_NAME) $(ENGINE_CHECK_RDB_NAME) $(ENGINE_CHECK_AOF_NAME) $(TLS_MODULE) $(RDMA_MODULE)
 	@echo ""
 	@echo "Hint: It's a good idea to run 'make test' ;)"
 	@echo ""
@@ -504,6 +506,10 @@ $(ENGINE_UNIT_TESTS): $(ENGINE_TEST_OBJ) $(ENGINE_LIB_NAME)
 $(ENGINE_SENTINEL_NAME): $(SERVER_NAME)
 	$(ENGINE_INSTALL) $(SERVER_NAME) $(ENGINE_SENTINEL_NAME)
 
+# valkey-senticache
+$(ENGINE_SENTICACHE_NAME): $(ENGINE_SENTICACHE_OBJ)
+	$(SERVER_LD) -o $@ $^ ../deps/hiredis/libhiredis.a ../deps/lua/src/liblua.a ../deps/hdr_histogram/libhdrhistogram.a ../deps/fpconv/libfpconv.a $(FINAL_LIBS)
+
 # valkey-check-rdb
 $(ENGINE_CHECK_RDB_NAME): $(SERVER_NAME)
 	$(ENGINE_INSTALL) $(SERVER_NAME) $(ENGINE_CHECK_RDB_NAME)
@@ -563,7 +569,7 @@ endif
 commands.c: $(COMMANDS_DEF_FILENAME).def
 
 clean:
-	rm -rf $(SERVER_NAME) $(ENGINE_SENTINEL_NAME) $(ENGINE_CLI_NAME) $(ENGINE_BENCHMARK_NAME) $(ENGINE_CHECK_RDB_NAME) $(ENGINE_CHECK_AOF_NAME) $(ENGINE_UNIT_TESTS) $(ENGINE_LIB_NAME) unit/*.o unit/*.d lua/*.o lua/*.d *.o *.gcda *.gcno *.gcov valkey.info lcov-html Makefile.dep *.so
+	rm -rf $(SERVER_NAME) $(ENGINE_SENTINEL_NAME) $(ENGINE_SENTICACHE_NAME) $(ENGINE_CLI_NAME) $(ENGINE_BENCHMARK_NAME) $(ENGINE_CHECK_RDB_NAME) $(ENGINE_CHECK_AOF_NAME) $(ENGINE_UNIT_TESTS) $(ENGINE_LIB_NAME) unit/*.o unit/*.d lua/*.o lua/*.d *.o *.gcda *.gcno *.gcov valkey.info lcov-html Makefile.dep *.so
 	rm -f $(DEP)
 
 .PHONY: clean
@@ -588,6 +594,9 @@ test-modules: $(SERVER_NAME)
 test-sentinel: $(ENGINE_SENTINEL_NAME) $(ENGINE_CLI_NAME)
 	@(cd ..; ./runtest-sentinel)
 
+test-senticache: $(ENGINE_SENTICACHE_NAME) $(ENGINE_CLI_NAME)
+	@(cd ..; ./runtest-senticache)
+
 test-cluster: $(SERVER_NAME) $(ENGINE_CLI_NAME)
 	@(cd ..; ./runtest-cluster)
 
@@ -626,6 +635,7 @@ helgrind:
 install: all
 	@mkdir -p $(INSTALL_BIN)
 	$(call MAKE_INSTALL,$(SERVER_NAME),$(INSTALL_BIN))
+	$(call MAKE_INSTALL,$(ENGINE_SENTICACHE_NAME),$(INSTALL_BIN))
 	$(call MAKE_INSTALL,$(ENGINE_BENCHMARK_NAME),$(INSTALL_BIN))
 	$(call MAKE_INSTALL,$(ENGINE_CLI_NAME),$(INSTALL_BIN))
 	@ln -sf $(SERVER_NAME) $(INSTALL_BIN)/$(ENGINE_CHECK_RDB_NAME)
diff --git a/src/commands.def b/src/commands.def
index e365f2c63..7909c0a68 100644
--- a/src/commands.def
+++ b/src/commands.def
@@ -5521,6 +5521,23 @@ struct COMMAND_STRUCT SCRIPT_Subcommands[] = {
 #define SCRIPT_Keyspecs NULL
 #endif
 
+/********** SENTINEL CACHE_UPDATE ********************/
+
+#ifndef SKIP_CMD_HISTORY_TABLE
+/* SENTINEL CACHE_UPDATE history */
+#define SENTINEL_CACHE_UPDATE_History NULL
+#endif
+
+#ifndef SKIP_CMD_TIPS_TABLE
+/* SENTINEL CACHE_UPDATE tips */
+#define SENTINEL_CACHE_UPDATE_Tips NULL
+#endif
+
+#ifndef SKIP_CMD_KEY_SPECS_TABLE
+/* SENTINEL CACHE_UPDATE key specs */
+#define SENTINEL_CACHE_UPDATE_Keyspecs NULL
+#endif
+
 /********** SENTINEL CKQUORUM ********************/
 
 #ifndef SKIP_CMD_HISTORY_TABLE
@@ -6086,6 +6103,7 @@ struct COMMAND_ARG SENTINEL_SLAVES_Args[] = {
 
 /* SENTINEL command table */
 struct COMMAND_STRUCT SENTINEL_Subcommands[] = {
+{MAKE_CMD("cache-update","Update Senticache state","O(1)","6.2.0",CMD_DOC_NONE,NULL,NULL,"sentinel",COMMAND_GROUP_SENTINEL,SENTINEL_CACHE_UPDATE_History,0,SENTINEL_CACHE_UPDATE_Tips,0,sentinelCommand,-4,CMD_ADMIN|CMD_SENTINEL|CMD_ONLY_SENTINEL,0,SENTINEL_CACHE_UPDATE_Keyspecs,0,NULL,0)},
 {MAKE_CMD("ckquorum","Checks for a Sentinel quorum.",NULL,"2.8.4",CMD_DOC_NONE,NULL,NULL,"sentinel",COMMAND_GROUP_SENTINEL,SENTINEL_CKQUORUM_History,0,SENTINEL_CKQUORUM_Tips,0,sentinelCommand,3,CMD_ADMIN|CMD_SENTINEL|CMD_ONLY_SENTINEL,0,SENTINEL_CKQUORUM_Keyspecs,0,NULL,1),.args=SENTINEL_CKQUORUM_Args},
 {MAKE_CMD("config","Configures Sentinel.","O(N) when N is the number of configuration parameters provided","6.2.0",CMD_DOC_NONE,NULL,NULL,"sentinel",COMMAND_GROUP_SENTINEL,SENTINEL_CONFIG_History,1,SENTINEL_CONFIG_Tips,0,sentinelCommand,-4,CMD_ADMIN|CMD_SENTINEL|CMD_ONLY_SENTINEL,0,SENTINEL_CONFIG_Keyspecs,0,NULL,1),.args=SENTINEL_CONFIG_Args},
 {MAKE_CMD("debug","Lists or updates the current configurable parameters of Sentinel.","O(N) where N is the number of configurable parameters","7.0.0",CMD_DOC_NONE,NULL,NULL,"sentinel",COMMAND_GROUP_SENTINEL,SENTINEL_DEBUG_History,0,SENTINEL_DEBUG_Tips,0,sentinelCommand,-2,CMD_ADMIN|CMD_SENTINEL|CMD_ONLY_SENTINEL,0,SENTINEL_DEBUG_Keyspecs,0,NULL,1),.args=SENTINEL_DEBUG_Args},
diff --git a/src/commands/sentinel-cache-update.json b/src/commands/sentinel-cache-update.json
new file mode 100644
index 000000000..acea39255
--- /dev/null
+++ b/src/commands/sentinel-cache-update.json
@@ -0,0 +1,17 @@
+{
+    "CACHE-UPDATE": {
+        "summary": "Update Senticache state",
+        "complexity": "O(1)",
+        "group": "sentinel",
+        "since": "6.2.0",
+        "arity": -4,
+        "container": "SENTINEL",
+        "function": "sentinelCommand",
+        "command_flags": [
+            "ADMIN",
+            "SENTINEL",
+            "ONLY_SENTINEL"
+        ],
+        "arguments": []
+    }
+}
diff --git a/src/senticache.c b/src/senticache.c
new file mode 100644
index 000000000..671b8d2b0
--- /dev/null
+++ b/src/senticache.c
@@ -0,0 +1,1750 @@
+/* Valkey SentiCache implementation */
+
+#include "server.h"
+#include "hiredis.h"
+#ifdef USE_OPENSSL
+#include "openssl/ssl.h"
+#include "hiredis_ssl.h"
+#endif
+#include "async.h"
+
+#include <ctype.h>
+#include <arpa/inet.h>
+#include <sys/socket.h>
+#include <sys/wait.h>
+#include <fcntl.h>
+
+extern char **environ;
+
+#ifdef USE_OPENSSL
+extern SSL_CTX *valkey_tls_ctx;
+extern SSL_CTX *valkey_tls_client_ctx;
+#endif
+
+#define VALKEY_SENTINEL_PORT 26379
+
+/* ======================== Sentinel global state =========================== */
+
+/* Address object, used to describe an ip:port pair. */
+typedef struct sentinelAddr {
+    char *hostname; /* Hostname OR address, as specified */
+    char *ip;       /* Always a resolved address */
+    int port;
+} sentinelAddr;
+
+/* A Sentinel Valkey Instance object is monitoring. */
+#define SRI_PRIMARY (1 << 0)
+#define SRI_REPLICA (1 << 1)
+#define SRI_SENTINEL (1 << 2)
+#define SRI_S_DOWN (1 << 3) /* Subjectively down (no quorum). */
+#define SRI_O_DOWN (1 << 4) /* Objectively down (confirmed by others). */
+#define SRI_PRIMARY_DOWN                                  \
+    (1 << 5) /* A Sentinel with this flag set thinks that \
+                its primary is down. */
+#define SRI_FAILOVER_IN_PROGRESS                                      \
+    (1 << 6)                           /* Failover is in progress for \
+                                          this primary. */
+#define SRI_PROMOTED (1 << 7)          /* Replica selected for promotion. */
+#define SRI_RECONF_SENT (1 << 8)       /* REPLICAOF <newprimary> sent. */
+#define SRI_RECONF_INPROG (1 << 9)     /* Replica synchronization in progress. */
+#define SRI_RECONF_DONE (1 << 10)      /* Replica synchronized with new primary. */
+#define SRI_FORCE_FAILOVER (1 << 11)   /* Force failover with primary up. */
+#define SRI_SCRIPT_KILL_SENT (1 << 12) /* SCRIPT KILL already sent on -BUSY */
+#define SRI_PRIMARY_REBOOT (1 << 13)   /* Primary was detected as rebooting */
+
+/* Note: times are in milliseconds. */
+#define SENTINEL_PING_PERIOD 1000
+
+static mstime_t sentinel_default_down_after = 30000;
+static mstime_t sentinel_default_failover_timeout = 60 * 3 * 1000;
+
+#define SENTINEL_DEFAULT_REPLICA_PRIORITY 100
+#define SENTINEL_DEFAULT_PARALLEL_SYNCS 1
+
+#define SENTINEL_DEFAULT_RESOLVE_HOSTNAMES 0
+#define SENTINEL_DEFAULT_ANNOUNCE_HOSTNAMES 0
+
+/* Failover machine different states. */
+#define SENTINEL_FAILOVER_STATE_NONE 0                 /* No failover in progress. */
+#define SENTINEL_FAILOVER_STATE_WAIT_START 1           /* Wait for failover_start_time*/
+#define SENTINEL_FAILOVER_STATE_SELECT_REPLICA 2       /* Select replica to promote */
+#define SENTINEL_FAILOVER_STATE_SEND_REPLICAOF_NOONE 3 /* Replica -> Primary */
+#define SENTINEL_FAILOVER_STATE_WAIT_PROMOTION 4       /* Wait replica to change role */
+#define SENTINEL_FAILOVER_STATE_RECONF_REPLICAS 5      /* REPLICAOF newprimary */
+#define SENTINEL_FAILOVER_STATE_UPDATE_CONFIG 6        /* Monitor promoted replica. */
+
+#define SENTINEL_PRIMARY_LINK_STATUS_UP 0
+#define SENTINEL_PRIMARY_LINK_STATUS_DOWN 1
+
+/* SENTINEL SIMULATE-FAILURE command flags. */
+#define SENTINEL_SIMFAILURE_NONE 0
+
+typedef struct sentinelValkeyInstance {
+    int flags;                                 /* See SRI_... defines */
+    char *name;                                /* Primary name from the point of view of this sentinel. */
+    char *runid;                               /* Run ID of this instance, or unique ID if is a Sentinel.*/
+    uint64_t config_epoch;                     /* Configuration epoch. */
+    sentinelAddr *addr;                        /* Primary host. */
+    mstime_t last_pub_time;                    /* Last time we sent hello via Pub/Sub. */
+    mstime_t last_hello_time;                  /* Only used if SRI_SENTINEL is set. Last time
+                                                  we received a hello from this Sentinel
+                                                  via Pub/Sub. */
+    mstime_t last_primary_down_reply_time;     /* Time of last reply to
+                                                 SENTINEL is-primary-down command. */
+    mstime_t s_down_since_time;                /* Subjectively down since time. */
+    mstime_t o_down_since_time;                /* Objectively down since time. */
+    mstime_t down_after_period;                /* Consider it down after that period. */
+    mstime_t primary_reboot_down_after_period; /* Consider primary down after that period. */
+    mstime_t primary_reboot_since_time;        /* primary reboot time since time. */
+    mstime_t info_refresh;                     /* Time at which we received INFO output from it. */
+
+    /* Role and the first time we observed it.
+     * This is useful in order to delay replacing what the instance reports
+     * with our own configuration. We need to always wait some time in order
+     * to give a chance to the leader to report the new configuration before
+     * we do silly things. */
+    int role_reported;
+    mstime_t role_reported_time;
+    mstime_t replica_conf_change_time; /* Last time replica primary addr changed. */
+
+    /* Primary specific. */
+    dict *sentinels;     /* Other sentinels monitoring the same primary. */
+    dict *replicas;      /* Replicas for this primary instance. */
+    unsigned int quorum; /* Number of sentinels that need to agree on failure. */
+    int parallel_syncs;  /* How many replicas to reconfigure at same time. */
+
+    /* Replica specific. */
+    mstime_t primary_link_down_time;        /* Replica replication link down time. */
+    int replica_priority;                   /* Replica priority according to its INFO output. */
+    int replica_announced;                  /* Replica announcing according to its INFO output. */
+    struct sentinelValkeyInstance *primary; /* Primary instance if it's replica. */
+    char *replica_primary_host;             /* Primary host as reported by INFO */
+    int replica_primary_port;               /* Primary port as reported by INFO */
+    int replica_primary_link_status;        /* Primary link status as reported by INFO */
+    unsigned long long replica_repl_offset; /* Replica replication offset. */
+    /* Failover */
+    char *leader;            /* If this is a primary instance, this is the runid of
+                                the Sentinel that should perform the failover. If
+                                this is a Sentinel, this is the runid of the Sentinel
+                                that this Sentinel voted as leader. */
+    uint64_t leader_epoch;   /* Epoch of the 'leader' field. */
+    uint64_t failover_epoch; /* Epoch of the currently started failover. */
+    int failover_state;      /* See SENTINEL_FAILOVER_STATE_* defines. */
+    mstime_t failover_state_change_time;
+    mstime_t failover_start_time;   /* Last failover attempt start time. */
+    mstime_t failover_timeout;      /* Max time to refresh failover state. */
+    mstime_t failover_delay_logged; /* For what failover_start_time value we
+                                       logged the failover delay. */
+    sds info;                       /* cached INFO output */
+} sentinelValkeyInstance;
+
+/* Main state. */
+struct sentinelState {
+    char myid[CONFIG_RUN_ID_SIZE + 1]; /* This sentinel ID. */
+    uint64_t current_epoch;            /* Current epoch. */
+    dict *primaries;                   /* Dictionary of primary sentinelValkeyInstances.
+                                        Key is the instance name, value is the
+                                        sentinelValkeyInstance structure pointer. */
+    int tilt;                          /* Are we in TILT mode? */
+    int running_scripts;               /* Number of scripts in execution right now. */
+    mstime_t tilt_start_time;          /* When TITL started. */
+    mstime_t previous_time;            /* Last time we ran the time handler. */
+    unsigned long simfailure_flags;    /* Failures simulation. */
+    sds cache_update_secret;           /* Secret for cache update command. */
+    int resolve_hostnames;             /* Support use of hostnames, assuming DNS is well configured. */
+    int announce_hostnames;            /* Announce hostnames instead of IPs when we have them. */
+} sentinel;
+
+/* ============================= Prototypes ================================= */
+
+sentinelValkeyInstance *sentinelGetPrimaryByName(char *name);
+sentinelValkeyInstance *sentinelGetPrimary(void);
+const char *sentinelValkeyInstanceTypeStr(sentinelValkeyInstance *ri);
+void sentinelEvent(int level, char *type, sentinelValkeyInstance *ri, const char *fmt, ...);
+int sentinelFlushConfig(void);
+sentinelValkeyInstance *sentinelGetPrimary(void);
+void initializeSentinelConfig(void);
+void freeSentinelConfig(void);
+
+/* ========================= Dictionary types =============================== */
+
+void releasesentinelValkeyInstance(sentinelValkeyInstance *ri);
+
+void dictInstancesValDestructor(void *obj) {
+    releasesentinelValkeyInstance(obj);
+}
+
+/* Instance name (sds) -> instance (sentinelValkeyInstance pointer)
+ *
+ * also used for: sentinelValkeyInstance->sentinels dictionary that maps
+ * sentinels ip:port to last seen time in Pub/Sub hello message. */
+dictType instancesDictType = {
+    dictSdsHash,                /* hash function */
+    NULL,                       /* key dup */
+    dictSdsKeyCompare,          /* key compare */
+    NULL,                       /* key destructor */
+    dictInstancesValDestructor, /* val destructor */
+    NULL                        /* allow to expand */
+};
+
+/* =========================== Initialization =============================== */
+
+/* This function overwrites a few normal Valkey config default with Sentinel
+ * specific defaults. */
+void initSentinelConfig(void) {
+    server.port = VALKEY_SENTINEL_PORT;
+    server.protected_mode = 0; /* Sentinel must be exposed. */
+}
+
+void freeSentinelLoadQueueEntry(void *item);
+
+/* Perform the Sentinel mode initialization. */
+void initSentinel(void) {
+    /* Initialize various data structures. */
+    sentinel.current_epoch = 0;
+    sentinel.primaries = dictCreate(&instancesDictType);
+    sentinel.tilt = 0;
+    sentinel.tilt_start_time = 0;
+    sentinel.previous_time = mstime();
+    sentinel.running_scripts = 0;
+    sentinel.simfailure_flags = SENTINEL_SIMFAILURE_NONE;
+    sentinel.resolve_hostnames = SENTINEL_DEFAULT_RESOLVE_HOSTNAMES;
+    sentinel.announce_hostnames = SENTINEL_DEFAULT_ANNOUNCE_HOSTNAMES;
+    sentinel.cache_update_secret = sdsnew("mysecret");
+    memset(sentinel.myid, 0, sizeof(sentinel.myid));
+    server.sentinel_config = NULL;
+}
+
+/* This function is for checking whether sentinel config file has been set,
+ * also checking whether we have write permissions. */
+void sentinelCheckConfigFile(void) {
+    if (server.configfile == NULL) {
+        serverLog(LL_WARNING, "Sentinel needs config file on disk to save state. Exiting...");
+        exit(1);
+    } else if (access(server.configfile, W_OK) == -1) {
+        serverLog(LL_WARNING, "Sentinel config file %s is not writable: %s. Exiting...", server.configfile,
+                  strerror(errno));
+        exit(1);
+    }
+}
+
+/* This function gets called when the server is in Sentinel mode, started,
+ * loaded the configuration, and is ready for normal operations. */
+void sentinelIsRunning(void) {
+    int j;
+
+    /* If this Sentinel has yet no ID set in the configuration file, we
+     * pick a random one and persist the config on disk. From now on this
+     * will be this Sentinel ID across restarts. */
+    for (j = 0; j < CONFIG_RUN_ID_SIZE; j++)
+        if (sentinel.myid[j] != 0) break;
+
+    if (j == CONFIG_RUN_ID_SIZE) {
+        /* Pick ID and persist the config. */
+        getRandomHexChars(sentinel.myid, CONFIG_RUN_ID_SIZE);
+        sentinelFlushConfig();
+    }
+
+    /* Log its ID to make debugging of issues simpler. */
+    serverLog(LL_WARNING, "Sentinel ID is %s", sentinel.myid);
+}
+
+/* ============================== sentinelAddr ============================== */
+
+/* Create a sentinelAddr object and return it on success.
+ * On error NULL is returned and errno is set to:
+ *  ENOENT: Can't resolve the hostname, unless accept_unresolved is non-zero.
+ *  EINVAL: Invalid port number.
+ */
+sentinelAddr *createSentinelAddr(char *hostname, int port, int is_accept_unresolved) {
+    char ip[NET_IP_STR_LEN];
+    sentinelAddr *sa;
+
+    if (port < 0 || port > 65535) {
+        errno = EINVAL;
+        return NULL;
+    }
+    if (anetResolve(NULL, hostname, ip, sizeof(ip), sentinel.resolve_hostnames ? ANET_NONE : ANET_IP_ONLY) ==
+        ANET_ERR) {
+        serverLog(LL_WARNING, "Failed to resolve hostname '%s'", hostname);
+        if (sentinel.resolve_hostnames && is_accept_unresolved) {
+            ip[0] = '\0';
+        } else {
+            errno = ENOENT;
+            return NULL;
+        }
+    }
+    sa = zmalloc(sizeof(*sa));
+    sa->hostname = sdsnew(hostname);
+    sa->ip = sdsnew(ip);
+    sa->port = port;
+    return sa;
+}
+
+/* Return a duplicate of the source address. */
+sentinelAddr *dupSentinelAddr(sentinelAddr *src) {
+    sentinelAddr *sa;
+
+    sa = zmalloc(sizeof(*sa));
+    sa->hostname = sdsnew(src->hostname);
+    sa->ip = sdsnew(src->ip);
+    sa->port = src->port;
+    return sa;
+}
+
+/* Free a Sentinel address. Can't fail. */
+void releaseSentinelAddr(sentinelAddr *sa) {
+    sdsfree(sa->hostname);
+    sdsfree(sa->ip);
+    zfree(sa);
+}
+
+/* Return non-zero if two addresses are equal. */
+int sentinelAddrIsEqual(sentinelAddr *a, sentinelAddr *b) {
+    return a->port == b->port && !strcasecmp(a->ip, b->ip);
+}
+
+/* Return non-zero if the two addresses are equal, either by address
+ * or by hostname if they could not have been resolved.
+ */
+int sentinelAddrOrHostnameEqual(sentinelAddr *a, sentinelAddr *b) {
+    return a->port == b->port && (!strcmp(a->ip, b->ip) || !strcasecmp(a->hostname, b->hostname));
+}
+
+/* Return non-zero if a hostname matches an address. */
+int sentinelAddrEqualsHostname(sentinelAddr *a, char *hostname) {
+    char ip[NET_IP_STR_LEN];
+
+    /* We always resolve the hostname and compare it to the address */
+    if (anetResolve(NULL, hostname, ip, sizeof(ip), sentinel.resolve_hostnames ? ANET_NONE : ANET_IP_ONLY) == ANET_ERR)
+        return 0;
+    return !strcasecmp(a->ip, ip);
+}
+
+const char *announceSentinelAddr(const sentinelAddr *a) {
+    return sentinel.announce_hostnames ? a->hostname : a->ip;
+}
+
+/* Return an allocated sds with hostname/address:port. IPv6
+ * addresses are bracketed the same way anetFormatAddr() does.
+ */
+sds announceSentinelAddrAndPort(const sentinelAddr *a) {
+    const char *addr = announceSentinelAddr(a);
+    if (strchr(addr, ':') != NULL)
+        return sdscatprintf(sdsempty(), "[%s]:%d", addr, a->port);
+    else
+        return sdscatprintf(sdsempty(), "%s:%d", addr, a->port);
+}
+
+/* =========================== Events notification ========================== */
+
+/* Send an event to log, pub/sub, user notification script.
+ *
+ * 'level' is the log level for logging. Only LL_WARNING events will trigger
+ * the execution of the user notification script.
+ *
+ * 'type' is the message type, also used as a pub/sub channel name.
+ *
+ * 'ri', is the valkey instance target of this event if applicable, and is
+ * used to obtain the path of the notification script to execute.
+ *
+ * The remaining arguments are printf-alike.
+ * If the format specifier starts with the two characters "%@" then ri is
+ * not NULL, and the message is prefixed with an instance identifier in the
+ * following format:
+ *
+ *  <instance type> <instance name> <ip> <port>
+ *
+ *  If the instance type is not primary, than the additional string is
+ *  added to specify the originating primary:
+ *
+ *  @ <primary name> <primary ip> <primary port>
+ *
+ *  Any other specifier after "%@" is processed by printf itself.
+ */
+void sentinelEvent(int level, char *type, sentinelValkeyInstance *ri, const char *fmt, ...) {
+    va_list ap;
+    char msg[LOG_MAX_LEN];
+    robj *channel, *payload;
+
+    /* Handle %@ */
+    if (fmt[0] == '%' && fmt[1] == '@') {
+        sentinelValkeyInstance *primary = (ri->flags & SRI_PRIMARY) ? NULL : ri->primary;
+
+        if (primary) {
+            snprintf(msg, sizeof(msg), "%s %s %s %d @ %s %s %d", sentinelValkeyInstanceTypeStr(ri), ri->name,
+                     announceSentinelAddr(ri->addr), ri->addr->port, primary->name, announceSentinelAddr(primary->addr),
+                     primary->addr->port);
+        } else {
+            snprintf(msg, sizeof(msg), "%s %s %s %d", sentinelValkeyInstanceTypeStr(ri), ri->name,
+                     announceSentinelAddr(ri->addr), ri->addr->port);
+        }
+        fmt += 2;
+    } else {
+        msg[0] = '\0';
+    }
+
+    /* Use vsprintf for the rest of the formatting if any. */
+    if (fmt[0] != '\0') {
+        va_start(ap, fmt);
+        vsnprintf(msg + strlen(msg), sizeof(msg) - strlen(msg), fmt, ap);
+        va_end(ap);
+    }
+
+    /* Log the message if the log level allows it to be logged. */
+    if (level >= server.verbosity) serverLog(level, "%s %s", type, msg);
+
+    /* Publish the message via Pub/Sub if it's not a debugging one. */
+    if (level != LL_DEBUG) {
+        channel = createStringObject(type, strlen(type));
+        payload = createStringObject(msg, strlen(msg));
+        pubsubPublishMessage(channel, payload, 0);
+        decrRefCount(channel);
+        decrRefCount(payload);
+    }
+}
+
+/* ========================== sentinelValkeyInstance ========================= */
+
+/* Create a valkey instance, the following fields must be populated by the
+ * caller if needed:
+ * runid: set to NULL but will be populated once INFO output is received.
+ * info_refresh: is set to 0 to mean that we never received INFO so far.
+ *
+ * If SRI_PRIMARY is set into initial flags the instance is added to
+ * sentinel.primaries table.
+ *
+ * if SRI_REPLICA or SRI_SENTINEL is set then 'primary' must be not NULL and the
+ * instance is added into primary->replicas or primary->sentinels table.
+ *
+ * If the instance is a replica, the name parameter is ignored and is created
+ * automatically as ip/hostname:port.
+ *
+ * The function fails if hostname can't be resolved or port is out of range.
+ * When this happens NULL is returned and errno is set accordingly to the
+ * createSentinelAddr() function.
+ *
+ * The function may also fail and return NULL with errno set to EBUSY if
+ * a primary with the same name, a replica with the same address, or a sentinel
+ * with the same ID already exists. */
+
+sentinelValkeyInstance *createsentinelValkeyInstance(char *name,
+                                                     int flags,
+                                                     char *hostname,
+                                                     int port,
+                                                     int quorum,
+                                                     sentinelValkeyInstance *primary) {
+    sentinelValkeyInstance *ri;
+    sentinelAddr *addr;
+    dict *table = NULL;
+    sds sdsname;
+
+    serverAssert(flags & (SRI_PRIMARY | SRI_REPLICA | SRI_SENTINEL));
+    serverAssert((flags & SRI_PRIMARY) || primary != NULL);
+
+    /* Check address validity. */
+    addr = createSentinelAddr(hostname, port, 1);
+    if (addr == NULL) return NULL;
+
+    /* For replicas use ip/host:port as name. */
+    if (flags & SRI_REPLICA)
+        sdsname = announceSentinelAddrAndPort(addr);
+    else
+        sdsname = sdsnew(name);
+
+    /* Make sure the entry is not duplicated. This may happen when the same
+     * name for a primary is used multiple times inside the configuration or
+     * if we try to add multiple times a replica or sentinel with same ip/port
+     * to a primary. */
+    if (flags & SRI_PRIMARY)
+        table = sentinel.primaries;
+    else if (flags & SRI_REPLICA)
+        table = primary->replicas;
+    else if (flags & SRI_SENTINEL)
+        table = primary->sentinels;
+    if (dictFind(table, sdsname)) {
+        releaseSentinelAddr(addr);
+        sdsfree(sdsname);
+        errno = EBUSY;
+        return NULL;
+    }
+
+    /* Create the instance object. */
+    ri = zmalloc(sizeof(*ri));
+    /* Note that all the instances are started in the disconnected state,
+     * the event loop will take care of connecting them. */
+    ri->flags = flags;
+    ri->name = sdsname;
+    ri->runid = NULL;
+    ri->config_epoch = 0;
+    ri->addr = addr;
+    ri->last_pub_time = mstime();
+    ri->last_hello_time = mstime();
+    ri->last_primary_down_reply_time = mstime();
+    ri->s_down_since_time = 0;
+    ri->o_down_since_time = 0;
+    ri->down_after_period = primary ? primary->down_after_period : sentinel_default_down_after;
+    ri->primary_reboot_down_after_period = 0;
+    ri->primary_link_down_time = 0;
+    ri->replica_priority = SENTINEL_DEFAULT_REPLICA_PRIORITY;
+    ri->replica_announced = 1;
+    ri->replica_primary_host = NULL;
+    ri->replica_primary_port = 0;
+    ri->replica_primary_link_status = SENTINEL_PRIMARY_LINK_STATUS_DOWN;
+    ri->replica_repl_offset = 0;
+    ri->sentinels = dictCreate(&instancesDictType);
+    ri->quorum = quorum;
+    ri->parallel_syncs = SENTINEL_DEFAULT_PARALLEL_SYNCS;
+    ri->primary = primary;
+    ri->replicas = dictCreate(&instancesDictType);
+    ri->info_refresh = 0;
+
+    /* Failover state. */
+    ri->leader = NULL;
+    ri->leader_epoch = 0;
+    ri->failover_epoch = 0;
+    ri->failover_state = SENTINEL_FAILOVER_STATE_NONE;
+    ri->failover_state_change_time = 0;
+    ri->failover_start_time = 0;
+    ri->failover_timeout = sentinel_default_failover_timeout;
+    ri->failover_delay_logged = 0;
+    ri->info = NULL;
+
+    /* Role */
+    ri->role_reported = ri->flags & (SRI_PRIMARY | SRI_REPLICA);
+    ri->role_reported_time = mstime();
+    ri->replica_conf_change_time = mstime();
+
+    /* Add into the right table. */
+    dictAdd(table, ri->name, ri);
+    return ri;
+}
+
+/* Release this instance and all its replicas, sentinels, hiredis connections.
+ * This function does not take care of unlinking the instance from the main
+ * primaries table (if it is a primary) or from its primary sentinels/replicas table
+ * if it is a replica or sentinel. */
+void releasesentinelValkeyInstance(sentinelValkeyInstance *ri) {
+    /* Release all its replicas or sentinels if any. */
+    dictRelease(ri->sentinels);
+    dictRelease(ri->replicas);
+
+    /* Free other resources. */
+    sdsfree(ri->name);
+    sdsfree(ri->runid);
+    sdsfree(ri->replica_primary_host);
+    sdsfree(ri->leader);
+    sdsfree(ri->info);
+    releaseSentinelAddr(ri->addr);
+
+    zfree(ri);
+}
+
+/* Lookup a replica in a primary valkey instance, by ip and port. */
+sentinelValkeyInstance *sentinelValkeyInstanceLookupReplica(sentinelValkeyInstance *ri, char *replica_addr, int port) {
+    sds key;
+    sentinelValkeyInstance *replica;
+    sentinelAddr *addr;
+
+    serverAssert(ri->flags & SRI_PRIMARY);
+
+    /* We need to handle a replica_addr that is potentially a hostname.
+     * If that is the case, depending on configuration we either resolve
+     * it and use the IP address or fail.
+     */
+    addr = createSentinelAddr(replica_addr, port, 0);
+    if (!addr) return NULL;
+    key = announceSentinelAddrAndPort(addr);
+    releaseSentinelAddr(addr);
+
+    replica = dictFetchValue(ri->replicas, key);
+    sdsfree(key);
+    return replica;
+}
+
+/* Return the name of the type of the instance as a string. */
+const char *sentinelValkeyInstanceTypeStr(sentinelValkeyInstance *ri) {
+    if (ri->flags & SRI_PRIMARY)
+        return "master";
+    else if (ri->flags & SRI_REPLICA)
+        return "slave";
+    else if (ri->flags & SRI_SENTINEL)
+        return "sentinel";
+    else
+        return "unknown";
+}
+
+/* Primary lookup by name */
+sentinelValkeyInstance *sentinelGetPrimaryByName(char *name) {
+    sentinelValkeyInstance *ri;
+    sds sdsname = sdsnew(name);
+
+    ri = dictFetchValue(sentinel.primaries, sdsname);
+    sdsfree(sdsname);
+    return ri;
+}
+
+/* Primary lookup */
+sentinelValkeyInstance *sentinelGetPrimary(void) {
+    dictIterator *di;
+    dictEntry *de;
+    sentinelValkeyInstance *ri = NULL;
+
+    di = dictGetIterator(sentinel.primaries);
+    while ((de = dictNext(di)) != NULL) {
+        ri = dictGetVal(de);
+        break;
+    }
+    dictReleaseIterator(di);
+    return ri;
+}
+
+/* Return the current primary address, that is, its address or the address
+ * of the promoted replica if already operational. */
+sentinelAddr *sentinelGetCurrentPrimaryAddress(sentinelValkeyInstance *primary) {
+    return primary->addr;
+}
+
+/* ============================ Config handling ============================= */
+
+/* init function for server.sentinel_config */
+void initializeSentinelConfig(void) {
+    server.sentinel_config = zmalloc(sizeof(struct sentinelConfig));
+    server.sentinel_config->monitor_cfg = listCreate();
+    server.sentinel_config->pre_monitor_cfg = listCreate();
+    server.sentinel_config->post_monitor_cfg = listCreate();
+    listSetFreeMethod(server.sentinel_config->monitor_cfg, freeSentinelLoadQueueEntry);
+    listSetFreeMethod(server.sentinel_config->pre_monitor_cfg, freeSentinelLoadQueueEntry);
+    listSetFreeMethod(server.sentinel_config->post_monitor_cfg, freeSentinelLoadQueueEntry);
+}
+
+/* destroy function for server.sentinel_config */
+void freeSentinelConfig(void) {
+    /* release these three config queues since we will not use it anymore */
+    listRelease(server.sentinel_config->pre_monitor_cfg);
+    listRelease(server.sentinel_config->monitor_cfg);
+    listRelease(server.sentinel_config->post_monitor_cfg);
+    zfree(server.sentinel_config);
+    server.sentinel_config = NULL;
+}
+
+/* free method for sentinelLoadQueueEntry when release the list */
+void freeSentinelLoadQueueEntry(void *item) {
+    struct sentinelLoadQueueEntry *entry = item;
+    sdsfreesplitres(entry->argv, entry->argc);
+    sdsfree(entry->line);
+    zfree(entry);
+}
+
+/* This function is used for queuing sentinel configuration, the main
+ * purpose of this function is to delay parsing the sentinel config option
+ * in order to avoid the order dependent issue from the config. */
+void queueSentinelConfig(sds *argv, int argc, int linenum, sds line) {
+    int i;
+    struct sentinelLoadQueueEntry *entry;
+
+    /* initialize sentinel_config for the first call */
+    if (server.sentinel_config == NULL) initializeSentinelConfig();
+
+    entry = zmalloc(sizeof(struct sentinelLoadQueueEntry));
+    entry->argv = zmalloc(sizeof(char *) * argc);
+    entry->argc = argc;
+    entry->linenum = linenum;
+    entry->line = sdsdup(line);
+    for (i = 0; i < argc; i++) {
+        entry->argv[i] = sdsdup(argv[i]);
+    }
+    listAddNodeTail(server.sentinel_config->pre_monitor_cfg, entry);
+}
+
+/* This function is used for loading the sentinel configuration from
+ * pre_monitor_cfg, monitor_cfg and post_monitor_cfg list */
+void loadSentinelConfigFromQueue(void) {
+    const char *err = NULL;
+    listIter li;
+    listNode *ln;
+    int linenum = 0;
+    sds line = NULL;
+    unsigned int j;
+
+    /* if there is no sentinel_config entry, we can return immediately */
+    if (server.sentinel_config == NULL) return;
+
+    list *sentinel_configs[3] = {server.sentinel_config->pre_monitor_cfg, server.sentinel_config->monitor_cfg,
+                                 server.sentinel_config->post_monitor_cfg};
+    /* loading from pre monitor config queue first to avoid dependency issues
+     * loading from monitor config queue
+     * loading from the post monitor config queue */
+    for (j = 0; j < sizeof(sentinel_configs) / sizeof(sentinel_configs[0]); j++) {
+        listRewind(sentinel_configs[j], &li);
+        while ((ln = listNext(&li))) {
+            struct sentinelLoadQueueEntry *entry = ln->value;
+            err = sentinelHandleConfiguration(entry->argv, entry->argc);
+            if (err) {
+                linenum = entry->linenum;
+                line = entry->line;
+                goto loaderr;
+            }
+        }
+    }
+
+    /* free sentinel_config when config loading is finished */
+    freeSentinelConfig();
+    return;
+
+loaderr:
+    fprintf(stderr, "\n*** FATAL CONFIG FILE ERROR (Valkey %s) ***\n", VALKEY_VERSION);
+    fprintf(stderr, "Reading the configuration file, at line %d\n", linenum);
+    fprintf(stderr, ">>> '%s'\n", line);
+    fprintf(stderr, "%s\n", err);
+    exit(1);
+}
+
+const char *sentinelHandleConfiguration(char **argv, int argc) {
+    if (!strcasecmp(argv[0], "myid") && argc == 2) {
+        if (strlen(argv[1]) != CONFIG_RUN_ID_SIZE) return "Malformed Sentinel id in myid option.";
+        memcpy(sentinel.myid, argv[1], CONFIG_RUN_ID_SIZE);
+    } else if (!strcasecmp(argv[0], "resolve-hostnames") && argc == 2) {
+        /* resolve-hostnames <yes|no> */
+        if ((sentinel.resolve_hostnames = yesnotoi(argv[1])) == -1) {
+            return "Please specify yes or no for the resolve-hostnames option.";
+        }
+    } else if (!strcasecmp(argv[0], "announce-hostnames") && argc == 2) {
+        /* announce-hostnames <yes|no> */
+        if ((sentinel.announce_hostnames = yesnotoi(argv[1])) == -1) {
+            return "Please specify yes or no for the announce-hostnames option.";
+        }
+    } else if (!strcasecmp(argv[0], "set-cache-update-secret") && argc == 2) {
+        /* set-cache-update-secret <secret> */
+        sdsfree(sentinel.cache_update_secret);
+        sentinel.cache_update_secret = sdsnew(argv[1]);
+    } else {
+        return "Unrecognized sentinel configuration statement.";
+    }
+    return NULL;
+}
+
+/* Implements CONFIG REWRITE for "sentinel" option.
+ * This is used not just to rewrite the configuration given by the user
+ * (the configured primaries) but also in order to retain the state of
+ * Sentinel across restarts: config epoch of primaries, associated replicas
+ * and sentinel instances, and so forth. */
+void rewriteConfigSentinelOption(struct rewriteConfigState *state) {
+    sds line;
+
+    /* sentinel unique ID. */
+    line = sdscatprintf(sdsempty(), "sentinel myid %s", sentinel.myid);
+    rewriteConfigRewriteLine(state, "sentinel myid", line, 1);
+
+    /* sentinel resolve-hostnames. */
+    line = sdscatprintf(sdsempty(), "sentinel resolve-hostnames %s", sentinel.resolve_hostnames ? "yes" : "no");
+    rewriteConfigRewriteLine(state, "sentinel resolve-hostnames", line,
+                             sentinel.resolve_hostnames != SENTINEL_DEFAULT_RESOLVE_HOSTNAMES);
+
+    /* sentinel set-cache-update-secret. */
+    if (strcasecmp(sentinel.cache_update_secret, "mysecret")) {
+        line = sdscatprintf(sdsempty(), "sentinel set-cache-update-secret %s", sentinel.cache_update_secret);
+        rewriteConfigRewriteLine(state, "sentinel set-cache-update-secret", line, 1);
+    }
+
+    /* sentinel announce-hostnames. */
+    line = sdscatprintf(sdsempty(), "sentinel announce-hostnames %s", sentinel.announce_hostnames ? "yes" : "no");
+    rewriteConfigRewriteLine(state, "sentinel announce-hostnames", line,
+                             sentinel.announce_hostnames != SENTINEL_DEFAULT_ANNOUNCE_HOSTNAMES);
+}
+
+/* This function uses the config rewriting Valkey engine in order to persist
+ * the state of the Sentinel in the current configuration file.
+ *
+ * Before returning the function calls fsync() against the generated
+ * configuration file to make sure changes are committed to disk.
+ *
+ * On failure the function logs a warning on the Valkey log. */
+int sentinelFlushConfig(void) {
+    int fd = -1;
+    int saved_hz = server.hz;
+    int rewrite_status;
+
+    server.hz = CONFIG_DEFAULT_HZ;
+    rewrite_status = rewriteConfig(server.configfile, 0);
+    server.hz = saved_hz;
+
+    if (rewrite_status == -1) goto werr;
+    if ((fd = open(server.configfile, O_RDONLY)) == -1) goto werr;
+    if (fsync(fd) == -1) goto werr;
+    if (close(fd) == EOF) goto werr;
+    serverLog(LL_NOTICE, "Sentinel new configuration saved on disk");
+    return C_OK;
+
+werr:
+    serverLog(LL_WARNING, "WARNING: Sentinel was not able to save the new configuration on disk!!!: %s",
+              strerror(errno));
+    if (fd != -1) close(fd);
+    return C_ERR;
+}
+
+/* =========================== SENTINEL command ============================= */
+
+const char *sentinelFailoverStateStr(int state) {
+    switch (state) {
+    case SENTINEL_FAILOVER_STATE_NONE: return "none";
+    case SENTINEL_FAILOVER_STATE_WAIT_START: return "wait_start";
+    case SENTINEL_FAILOVER_STATE_SELECT_REPLICA: return "select_replica";
+    case SENTINEL_FAILOVER_STATE_SEND_REPLICAOF_NOONE: return "send_replicaof_noone";
+    case SENTINEL_FAILOVER_STATE_WAIT_PROMOTION: return "wait_promotion";
+    case SENTINEL_FAILOVER_STATE_RECONF_REPLICAS: return "reconf_replicas";
+    case SENTINEL_FAILOVER_STATE_UPDATE_CONFIG: return "update_config";
+    default: return "unknown";
+    }
+}
+
+/* Valkey instance to Valkey protocol representation. */
+void addReplysentinelValkeyInstance(client *c, sentinelValkeyInstance *ri) {
+    char *flags = sdsempty();
+    void *mbl;
+    int fields = 0;
+
+    mbl = addReplyDeferredLen(c);
+
+    addReplyBulkCString(c, "name");
+    addReplyBulkCString(c, ri->name);
+    fields++;
+
+    addReplyBulkCString(c, "ip");
+    addReplyBulkCString(c, announceSentinelAddr(ri->addr));
+    fields++;
+
+    addReplyBulkCString(c, "port");
+    addReplyBulkLongLong(c, ri->addr->port);
+    fields++;
+
+    addReplyBulkCString(c, "runid");
+    addReplyBulkCString(c, ri->runid ? ri->runid : "");
+    fields++;
+
+    addReplyBulkCString(c, "flags");
+    if (ri->flags & SRI_S_DOWN) flags = sdscat(flags, "s_down,");
+    if (ri->flags & SRI_O_DOWN) flags = sdscat(flags, "o_down,");
+    if (ri->flags & SRI_PRIMARY) flags = sdscat(flags, "master,");
+    if (ri->flags & SRI_REPLICA) flags = sdscat(flags, "slave,");
+    if (ri->flags & SRI_SENTINEL) flags = sdscat(flags, "sentinel,");
+    if (ri->flags & SRI_PRIMARY_DOWN) flags = sdscat(flags, "master_down,");
+    if (ri->flags & SRI_FAILOVER_IN_PROGRESS) flags = sdscat(flags, "failover_in_progress,");
+    if (ri->flags & SRI_PROMOTED) flags = sdscat(flags, "promoted,");
+    if (ri->flags & SRI_RECONF_SENT) flags = sdscat(flags, "reconf_sent,");
+    if (ri->flags & SRI_RECONF_INPROG) flags = sdscat(flags, "reconf_inprog,");
+    if (ri->flags & SRI_RECONF_DONE) flags = sdscat(flags, "reconf_done,");
+    if (ri->flags & SRI_FORCE_FAILOVER) flags = sdscat(flags, "force_failover,");
+    if (ri->flags & SRI_SCRIPT_KILL_SENT) flags = sdscat(flags, "script_kill_sent,");
+
+    if (sdslen(flags) != 0) sdsrange(flags, 0, -2); /* remove last "," */
+    addReplyBulkCString(c, flags);
+    sdsfree(flags);
+    fields++;
+
+    addReplyBulkCString(c, "link-pending-commands");
+    addReplyBulkLongLong(c, 0);
+    fields++;
+
+    addReplyBulkCString(c, "link-refcount");
+    addReplyBulkLongLong(c, 0);
+    fields++;
+
+    if (ri->flags & SRI_FAILOVER_IN_PROGRESS) {
+        addReplyBulkCString(c, "failover-state");
+        addReplyBulkCString(c, (char *)sentinelFailoverStateStr(ri->failover_state));
+        fields++;
+    }
+
+    addReplyBulkCString(c, "last-ping-sent");
+    addReplyBulkLongLong(c, 0);
+    fields++;
+
+    addReplyBulkCString(c, "last-ok-ping-reply");
+    addReplyBulkLongLong(c, 0);
+    fields++;
+
+    addReplyBulkCString(c, "last-ping-reply");
+    addReplyBulkLongLong(c, 0);
+    fields++;
+
+    if (ri->flags & SRI_S_DOWN) {
+        addReplyBulkCString(c, "s-down-time");
+        addReplyBulkLongLong(c, mstime() - ri->s_down_since_time);
+        fields++;
+    }
+
+    if (ri->flags & SRI_O_DOWN) {
+        addReplyBulkCString(c, "o-down-time");
+        addReplyBulkLongLong(c, mstime() - ri->o_down_since_time);
+        fields++;
+    }
+
+    addReplyBulkCString(c, "down-after-milliseconds");
+    addReplyBulkLongLong(c, ri->down_after_period);
+    fields++;
+
+    /* Primarys and Replicas */
+    if (ri->flags & (SRI_PRIMARY | SRI_REPLICA)) {
+        addReplyBulkCString(c, "info-refresh");
+        addReplyBulkLongLong(c, 0);
+        fields++;
+
+        addReplyBulkCString(c, "role-reported");
+        addReplyBulkCString(c, (ri->role_reported == SRI_PRIMARY) ? "master" : "slave");
+        fields++;
+
+        addReplyBulkCString(c, "role-reported-time");
+        addReplyBulkLongLong(c, mstime() - ri->role_reported_time);
+        fields++;
+    }
+
+    /* Only primaries */
+    if (ri->flags & SRI_PRIMARY) {
+        addReplyBulkCString(c, "config-epoch");
+        addReplyBulkLongLong(c, ri->config_epoch);
+        fields++;
+
+        addReplyBulkCString(c, "num-slaves");
+        addReplyBulkLongLong(c, dictSize(ri->replicas));
+        fields++;
+
+        addReplyBulkCString(c, "num-other-sentinels");
+        addReplyBulkLongLong(c, dictSize(ri->sentinels));
+        fields++;
+
+        addReplyBulkCString(c, "quorum");
+        addReplyBulkLongLong(c, ri->quorum);
+        fields++;
+
+        addReplyBulkCString(c, "failover-timeout");
+        addReplyBulkLongLong(c, ri->failover_timeout);
+        fields++;
+
+        addReplyBulkCString(c, "parallel-syncs");
+        addReplyBulkLongLong(c, ri->parallel_syncs);
+        fields++;
+    }
+
+    /* Only replicas */
+    if (ri->flags & SRI_REPLICA) {
+        addReplyBulkCString(c, "master-link-down-time");
+        addReplyBulkLongLong(c, ri->primary_link_down_time);
+        fields++;
+
+        addReplyBulkCString(c, "master-link-status");
+        addReplyBulkCString(c, (ri->replica_primary_link_status == SENTINEL_PRIMARY_LINK_STATUS_UP) ? "ok" : "err");
+        fields++;
+
+        addReplyBulkCString(c, "master-host");
+        addReplyBulkCString(c, ri->replica_primary_host ? ri->replica_primary_host : "?");
+        fields++;
+
+        addReplyBulkCString(c, "master-port");
+        addReplyBulkLongLong(c, ri->replica_primary_port);
+        fields++;
+
+        addReplyBulkCString(c, "slave-priority");
+        addReplyBulkLongLong(c, ri->replica_priority);
+        fields++;
+
+        addReplyBulkCString(c, "slave-repl-offset");
+        addReplyBulkLongLong(c, ri->replica_repl_offset);
+        fields++;
+
+        addReplyBulkCString(c, "replica-announced");
+        addReplyBulkLongLong(c, ri->replica_announced);
+        fields++;
+    }
+
+    /* Only sentinels */
+    if (ri->flags & SRI_SENTINEL) {
+        addReplyBulkCString(c, "last-hello-message");
+        addReplyBulkLongLong(c, 0);
+        fields++;
+
+        addReplyBulkCString(c, "voted-leader");
+        addReplyBulkCString(c, ri->leader ? ri->leader : "?");
+        fields++;
+
+        addReplyBulkCString(c, "voted-leader-epoch");
+        addReplyBulkLongLong(c, ri->leader_epoch);
+        fields++;
+    }
+
+    setDeferredMapLen(c, mbl, fields);
+}
+
+/* Output a number of instances contained inside a dictionary as
+ * Valkey protocol. */
+void addReplyDictOfValkeyInstances(client *c, dict *instances) {
+    dictIterator *di;
+    dictEntry *de;
+    long replicas = 0;
+    void *replylen = addReplyDeferredLen(c);
+
+    di = dictGetIterator(instances);
+    while ((de = dictNext(di)) != NULL) {
+        sentinelValkeyInstance *ri = dictGetVal(de);
+
+        /* don't announce unannounced replicas */
+        if (ri->flags & SRI_REPLICA && !ri->replica_announced) continue;
+        addReplysentinelValkeyInstance(c, ri);
+        replicas++;
+    }
+    dictReleaseIterator(di);
+    setDeferredArrayLen(c, replylen, replicas);
+}
+
+/* Get first primary and use it. If no primaries are in the cache reply with error. */
+sentinelValkeyInstance *sentinelGetPrimaryOrReplyError(client *c) {
+    dictIterator *di;
+    dictEntry *de;
+    sentinelValkeyInstance *ri = NULL;
+
+    di = dictGetIterator(sentinel.primaries);
+    while ((de = dictNext(di)) != NULL) {
+        ri = dictGetVal(de);
+        break;
+    }
+    dictReleaseIterator(di);
+    if (!ri) {
+        addReplyError(c, "No such master with that name");
+        return NULL;
+    }
+    return ri;
+}
+
+sentinelAddr *parseAddr(client *c, sds addr) {
+    int count = 0;
+    unsigned long port = 0;
+    sentinelAddr *ret = NULL;
+
+    sds *args = sdssplitlen(addr, sdslen(addr), " ", 1, &count);
+    if (args == NULL) {
+        addReplyErrorFormat(c, "Unable to split addr: %s", addr);
+        return ret;
+    }
+    if (count != 2) {
+        addReplyErrorFormat(c, "Unexpected number of tokens in addr: %d (expected 2)", count);
+        goto cleanup;
+    }
+
+    port = strtoul(args[1], NULL, 10);
+    if (port < 1 || port > 65535) {
+        addReplyErrorFormat(c, "Invalid port value: %s", args[1]);
+        goto cleanup;
+    }
+
+    ret = createSentinelAddr(args[0], port, 0);
+    if (ret == NULL) {
+        addReplyErrorFormat(c, "Unable to resolve hostname: %s", args[0]); /* Port is already validated */
+        goto cleanup;
+    }
+
+cleanup:
+    sdsfreesplitres(args, count);
+    return ret;
+}
+
+static int sentinelUpdatePrimaryName(client *c, sds name) {
+    dictIterator *di;
+    dictEntry *de;
+    sentinelValkeyInstance *ri = NULL;
+
+    di = dictGetIterator(sentinel.primaries);
+    while ((de = dictNext(di)) != NULL) {
+        ri = dictGetVal(de);
+        break;
+    }
+    dictReleaseIterator(di);
+    if (ri && !strcasecmp(name, ri->name)) {
+        return 0;
+    }
+    sentinelValkeyInstance *newRi = createsentinelValkeyInstance(name, SRI_PRIMARY, "127.0.0.1", 0, 0, NULL);
+    if (newRi == NULL) {
+        addReplyError(c, "Creation of new master failed");
+        return 1;
+    }
+    if (ri) {
+        sentinelValkeyInstance *origRi = NULL;
+        sentinelValkeyInstance *copyRi = NULL;
+        di = dictGetIterator(ri->sentinels);
+        while ((de = dictNext(di)) != NULL) {
+            origRi = dictGetVal(de);
+            copyRi = createsentinelValkeyInstance(origRi->name, origRi->flags, origRi->addr->hostname,
+                                                  origRi->addr->port, 0, newRi);
+            if (copyRi == NULL) {
+                addReplyError(c, "Sentinel copy failed");
+                dictReleaseIterator(di);
+                return 1;
+            }
+        }
+        dictReleaseIterator(di);
+        origRi = NULL;
+        copyRi = NULL;
+        di = dictGetIterator(ri->replicas);
+        while ((de = dictNext(di)) != NULL) {
+            origRi = dictGetVal(de);
+            copyRi = createsentinelValkeyInstance(origRi->name, origRi->flags, origRi->addr->hostname,
+                                                  origRi->addr->port, 0, newRi);
+            if (copyRi == NULL) {
+                addReplyError(c, "Replica copy failed");
+                dictReleaseIterator(di);
+                return 1;
+            }
+        }
+        dictReleaseIterator(di);
+        releaseSentinelAddr(newRi->addr);
+        newRi->addr = dupSentinelAddr(ri->addr);
+        if (ri->runid) {
+            newRi->runid = sdsdup(ri->runid);
+        }
+        newRi->config_epoch = ri->config_epoch;
+        newRi->role_reported_time = ri->role_reported_time;
+        if (dictDelete(sentinel.primaries, ri->name) != DICT_OK) {
+            addReplyError(c, "Old master delete failed");
+            return 1;
+        }
+    } else {
+        newRi->role_reported_time = mstime();
+    }
+
+    return 0;
+}
+
+static int sentinelUpdatePrimaryAddr(client *c, sds addr) {
+    sentinelValkeyInstance *ri = sentinelGetPrimaryOrReplyError(c);
+
+    if (!ri) {
+        return 1;
+    }
+
+    sentinelAddr *newValue = parseAddr(c, addr);
+
+    if (newValue == NULL) {
+        return 1;
+    }
+
+    if (!sentinelAddrOrHostnameEqual(newValue, ri->addr)) {
+        int needEvent = 0;
+        if (ri->addr->port != 0) {
+            needEvent = 1;
+            dictRelease(ri->replicas);
+            ri->replicas = dictCreate(&instancesDictType);
+            sentinelEvent(LL_WARNING, "+switch-master", ri, "%s %s %d %s %d", ri->name, announceSentinelAddr(ri->addr),
+                          ri->addr->port, announceSentinelAddr(newValue), newValue->port);
+            ri->role_reported_time = mstime();
+        }
+        releaseSentinelAddr(ri->addr);
+        ri->addr = newValue;
+        if (needEvent == 1) {
+            // A workaround for lettuce
+            sentinelEvent(LL_WARNING, "failover-end", ri, "%@");
+        }
+    } else {
+        releaseSentinelAddr(newValue);
+    }
+
+    return 0;
+}
+
+static int sentinelUpdatePrimarySpec(client *c, sds spec) {
+    int count = 0;
+    int ret = 0;
+    unsigned long quorum = 0;
+    unsigned long parallel_syncs = 0;
+    uint64_t config_epoch = 0;
+
+    sentinelValkeyInstance *ri = sentinelGetPrimaryOrReplyError(c);
+
+    if (!ri) {
+        return 1;
+    }
+
+    sds *args = sdssplitlen(spec, sdslen(spec), " ", 1, &count);
+    if (args == NULL) {
+        addReplyErrorFormat(c, "Unable to split spec: %s", spec);
+        return 1;
+    }
+    if (count != 4) {
+        addReplyErrorFormat(c, "Unexpected number of tokens in spec: %d (expected 4)", count);
+        sdsfreesplitres(args, count);
+        return 1;
+    }
+
+    if (ri->runid == NULL || strcmp(args[0], ri->runid)) {
+        sdsfree(ri->runid);
+        ri->runid = sdsdup(args[0]);
+    }
+
+    quorum = strtoul(args[1], NULL, 10);
+
+    if (quorum == 0 || quorum >= server.maxclients) {
+        addReplyErrorFormat(c, "Invalid quorum value: %lu", quorum);
+        ret = 1;
+    } else {
+        ri->quorum = quorum;
+    }
+
+    parallel_syncs = strtoul(args[2], NULL, 10);
+
+    if (parallel_syncs == 0 || parallel_syncs >= server.maxclients) {
+        addReplyErrorFormat(c, "Invalid parallel_syncs value: %lu", parallel_syncs);
+        ret = 1;
+    } else {
+        ri->parallel_syncs = parallel_syncs;
+    }
+
+    config_epoch = strtoull(args[3], NULL, 10);
+    if (ri->config_epoch != config_epoch) {
+        ri->config_epoch = config_epoch;
+        sentinelEvent(LL_WARNING, "+new-epoch", ri, "%llu", ri->config_epoch);
+    }
+
+    sdsfreesplitres(args, count);
+    return ret;
+}
+
+static int sentinelUpdateReplicaSpec(client *c, sds spec) {
+    int count = 0;
+    int ret = 0;
+    unsigned long port = 0;
+    sentinelAddr *addr = NULL;
+    sentinelValkeyInstance *ri = NULL;
+
+    sentinelValkeyInstance *primaryRi = sentinelGetPrimaryOrReplyError(c);
+
+    if (!primaryRi) {
+        return 1;
+    }
+
+    sds *args = sdssplitlen(spec, sdslen(spec), " ", 1, &count);
+    if (args == NULL) {
+        addReplyErrorFormat(c, "Unable to split replica spec: %s", spec);
+        return 1;
+    }
+    if (count != 10) {
+        addReplyErrorFormat(c, "Unexpected number of tokens in replica spec: %d (expected 10)", count);
+        sdsfreesplitres(args, count);
+        return 1;
+    }
+
+    port = strtoul(args[1], NULL, 10);
+    if (port < 1 || port > 65535) {
+        addReplyErrorFormat(c, "Invalid port value: %s", args[1]);
+        ret = 1;
+        goto cleanup;
+    }
+
+    addr = createSentinelAddr(args[0], port, 0);
+    if (addr == NULL) {
+        addReplyErrorFormat(c, "Unable to resolve hostname: %s", args[0]); /* Port is already validated */
+        ret = 1;
+        goto cleanup;
+    }
+
+    ri = sentinelValkeyInstanceLookupReplica(primaryRi, addr->hostname, addr->port);
+
+    if (ri == NULL) {
+        addReplyErrorFormat(c, "Unable to find replica by %s:%d", addr->hostname, addr->port);
+        ret = 1;
+        goto cleanup;
+    }
+
+    if (ri->runid == NULL || strcmp(args[2], ri->runid)) {
+        sdsfree(ri->runid);
+        ri->runid = sdsdup(args[2]);
+    }
+
+    ri->primary_link_down_time = strtoll(args[3], NULL, 10);
+    ri->replica_priority = strtol(args[4], NULL, 10);
+    ri->replica_announced = strtol(args[5], NULL, 10);
+
+    if (ri->replica_primary_host == NULL || strcmp(args[6], ri->replica_primary_host)) {
+        sdsfree(ri->replica_primary_host);
+        ri->replica_primary_host = sdsdup(args[6]);
+    }
+
+    ri->replica_primary_port = strtoul(args[7], NULL, 10);
+    ri->replica_primary_link_status = strtol(args[8], NULL, 10);
+    ri->replica_repl_offset = strtoull(args[9], NULL, 10);
+cleanup:
+    if (addr != NULL) {
+        releaseSentinelAddr(addr);
+    }
+    sdsfreesplitres(args, count);
+    return ret;
+}
+
+static int sentinelAddReplica(client *c, sds addr) {
+    sentinelValkeyInstance *primaryRi = sentinelGetPrimaryOrReplyError(c);
+
+    if (!primaryRi) {
+        return 1;
+    }
+
+    sentinelValkeyInstance *ri = NULL;
+    sentinelAddr *addrValue = parseAddr(c, addr);
+
+    if (addrValue == NULL) {
+        return 1;
+    }
+
+    if (sentinelAddrIsEqual(primaryRi->addr, addrValue)) {
+        addReplyErrorFormat(c, "Addr %s:%d is already assigned to master", addrValue->hostname, addrValue->port);
+        releaseSentinelAddr(addrValue);
+        return 1;
+    }
+
+    ri = createsentinelValkeyInstance("", SRI_REPLICA, addrValue->hostname, addrValue->port, 0, primaryRi);
+    if (ri) {
+        ri->role_reported_time = mstime();
+        sentinelEvent(LL_NOTICE, "+slave", ri, "%@");
+    }
+
+    releaseSentinelAddr(addrValue);
+    return 0;
+}
+
+static int sentinelAddSentinel(client *c, sds spec) {
+    sentinelValkeyInstance *primaryRi = sentinelGetPrimaryOrReplyError(c);
+
+    if (!primaryRi) {
+        return 1;
+    }
+
+    int ret = 0;
+    int count = 0;
+    unsigned long port = 0;
+    sentinelAddr *addr = NULL;
+
+    sds *args = sdssplitlen(spec, sdslen(spec), " ", 1, &count);
+    if (args == NULL) {
+        addReplyErrorFormat(c, "Unable to split sentinel spec: %s", spec);
+        return 1;
+    }
+    if (count != 4) {
+        addReplyErrorFormat(c, "Unexpected number of tokens in sentinel spec: %d (expected 4)", count);
+        ret = 1;
+        goto cleanup;
+    }
+
+    port = strtoul(args[3], NULL, 10);
+    if (port < 1 || port > 65535) {
+        addReplyErrorFormat(c, "Invalid port value: %s", args[3]);
+        ret = 1;
+        goto cleanup;
+    }
+
+    addr = createSentinelAddr(args[2], port, 0);
+    if (addr == NULL) {
+        addReplyErrorFormat(c, "Unable to resolve hostname: %s", args[2]); /* Port is already validated */
+        ret = 1;
+        goto cleanup;
+    }
+
+    sentinelValkeyInstance *ri = NULL;
+
+    ri = createsentinelValkeyInstance(args[0], SRI_SENTINEL, addr->hostname, addr->port, 0, primaryRi);
+    if (ri) {
+        ri->runid = sdsdup(args[1]);
+        sentinelEvent(LL_NOTICE, "+sentinel", ri, "%@");
+    }
+
+cleanup:
+    sdsfreesplitres(args, count);
+    if (addr != NULL) {
+        releaseSentinelAddr(addr);
+    }
+    return ret;
+}
+
+static int sentinelDeleteReplica(client *c, sds addr) {
+    sentinelValkeyInstance *ri = sentinelGetPrimaryOrReplyError(c);
+
+    if (!ri) {
+        return 1;
+    }
+
+    sentinelAddr *addrValue = parseAddr(c, addr);
+    if (addrValue == NULL) {
+        return 1;
+    }
+
+    sds key = announceSentinelAddrAndPort(addrValue);
+    dictDelete(ri->replicas, key);
+    sdsfree(key);
+
+    releaseSentinelAddr(addrValue);
+    return 0;
+}
+
+static int sentinelDeleteSentinel(client *c, sds name) {
+    sentinelValkeyInstance *ri = sentinelGetPrimaryOrReplyError(c);
+
+    if (!ri) {
+        return 1;
+    }
+
+    dictDelete(ri->sentinels, name);
+
+    return 0;
+}
+
+static int sentinelUpdateCacheKey(client *c, sds key, sds value) {
+    if (!strcasecmp(key, "master-name")) {
+        return sentinelUpdatePrimaryName(c, value);
+    } else if (!strcasecmp(key, "master-addr")) {
+        return sentinelUpdatePrimaryAddr(c, value);
+    } else if (!strcasecmp(key, "master-spec")) {
+        return sentinelUpdatePrimarySpec(c, value);
+    } else if (!strcasecmp(key, "slave-spec")) {
+        return sentinelUpdateReplicaSpec(c, value);
+    } else if (!strcasecmp(key, "add-replica")) {
+        return sentinelAddReplica(c, value);
+    } else if (!strcasecmp(key, "add-sentinel")) {
+        return sentinelAddSentinel(c, value);
+    } else if (!strcasecmp(key, "delete-replica")) {
+        return sentinelDeleteReplica(c, value);
+    } else if (!strcasecmp(key, "delete-sentinel")) {
+        return sentinelDeleteSentinel(c, value);
+    } else {
+        addReplyError(c, "Unknown key");
+        return 1;
+    }
+    return 0;
+}
+
+typedef enum {
+    CPS_KEY_START = 0,
+    CPS_KEY_READ = 1,
+    CPS_VALUE_START = 2,
+    CPS_VALUE_READ = 3,
+} CacheParserState;
+
+/* Update internal state with provided one */
+static void sentinelCacheUpdate(client *c) {
+    sds updateCommand = sdsempty();
+    sds key = sdsempty();
+    sds value = sdsempty();
+    CacheParserState parserState = CPS_KEY_START;
+    size_t keyStart = 0;
+    size_t keyEnd = 0;
+    size_t valueStart = 0;
+    size_t valueEnd = 0;
+
+    for (int i = 3; i < c->argc; i++) {
+        updateCommand = sdscatsds(updateCommand, c->argv[i]->ptr);
+        if (i != c->argc - 1) {
+            updateCommand = sdscatlen(updateCommand, " ", 1);
+        }
+    }
+
+    for (size_t i = 0; i < sdslen(updateCommand); i++) {
+        switch (parserState) {
+        case CPS_KEY_START:
+            if (!isspace(updateCommand[i])) {
+                parserState = CPS_KEY_READ;
+                keyStart = i;
+            }
+            break;
+        case CPS_KEY_READ:
+            if (updateCommand[i] == ':') {
+                keyEnd = i;
+                parserState = CPS_VALUE_START;
+            }
+            break;
+        case CPS_VALUE_START:
+            if (!isspace(updateCommand[i])) {
+                parserState = CPS_VALUE_READ;
+                valueStart = i;
+            }
+            break;
+        case CPS_VALUE_READ:
+            if (updateCommand[i] == ',') {
+                parserState = CPS_KEY_START;
+                valueEnd = i;
+                key = sdscatlen(key, updateCommand + keyStart, keyEnd - keyStart);
+                value = sdscatlen(value, updateCommand + valueStart, valueEnd - valueStart);
+                if (sentinelUpdateCacheKey(c, key, value) != 0) {
+                    goto cleanup;
+                }
+                sdsfree(key);
+                sdsfree(value);
+                key = sdsempty();
+                value = sdsempty();
+            }
+            break;
+        }
+    }
+
+    if (parserState == CPS_VALUE_READ) {
+        key = sdscatlen(key, updateCommand + keyStart, keyEnd - keyStart);
+        value = sdscatlen(value, updateCommand + valueStart, sdslen(updateCommand) - valueStart);
+        if (sentinelUpdateCacheKey(c, key, value) == 0) {
+            parserState = CPS_KEY_START;
+        }
+    }
+
+    if (parserState == CPS_KEY_START) {
+        addReply(c, shared.ok);
+    }
+
+cleanup:
+    sdsfree(key);
+    sdsfree(value);
+    sdsfree(updateCommand);
+}
+
+void sentinelCommand(client *c) {
+    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr, "help")) {
+        const char *help[] = {"CKQUORUM <master-name>",
+                              "    Check if the current Sentinel configuration is able to reach the quorum",
+                              "    needed to failover a master and the majority needed to authorize the",
+                              "    failover.",
+                              "GET-MASTER-ADDR-BY-NAME <master-name>",
+                              "    Return the ip and port number of the master with that name.",
+                              "INFO-CACHE <master-name>",
+                              "    Return last cached INFO output from primaries and all its replicas.",
+                              "MASTER <master-name>",
+                              "    Show the state and info of the specified master.",
+                              "MASTERS",
+                              "    Show a list of monitored masters and their state.",
+                              "MYID",
+                              "    Return the ID of the Sentinel instance.",
+                              "SLAVES <master-name>",
+                              "    Show a list of slaves for this master and their state.",
+                              "SENTINELS <master-name>",
+                              "    Show a list of Sentinel instances for this master and their state.",
+                              NULL};
+        addReplyHelp(c, help);
+    } else if (!strcasecmp(c->argv[1]->ptr, "cache-update")) {
+        if (c->argc < 4) goto numargserr;
+        if (!strcasecmp(c->argv[2]->ptr, sentinel.cache_update_secret)) {
+            sentinelCacheUpdate(c);
+        } else {
+            addReplySubcommandSyntaxError(c);
+        }
+    } else if (!strcasecmp(c->argv[1]->ptr, "masters")) {
+        /* SENTINEL MASTERS */
+        if (c->argc != 2) goto numargserr;
+        addReplyDictOfValkeyInstances(c, sentinel.primaries);
+    } else if (!strcasecmp(c->argv[1]->ptr, "master")) {
+        /* SENTINEL MASTER <name> */
+        sentinelValkeyInstance *ri;
+
+        if (c->argc != 3) goto numargserr;
+        if ((ri = sentinelGetPrimaryOrReplyError(c)) == NULL) return;
+        addReplysentinelValkeyInstance(c, ri);
+    } else if (!strcasecmp(c->argv[1]->ptr, "slaves") || !strcasecmp(c->argv[1]->ptr, "replicas")) {
+        /* SENTINEL REPLICAS <master-name> */
+        sentinelValkeyInstance *ri;
+
+        if (c->argc != 3) goto numargserr;
+        if ((ri = sentinelGetPrimaryOrReplyError(c)) == NULL) return;
+        addReplyDictOfValkeyInstances(c, ri->replicas);
+    } else if (!strcasecmp(c->argv[1]->ptr, "sentinels")) {
+        /* SENTINEL SENTINELS <master-name> */
+        sentinelValkeyInstance *ri;
+
+        if (c->argc != 3) goto numargserr;
+        if ((ri = sentinelGetPrimaryOrReplyError(c)) == NULL) return;
+        addReplyDictOfValkeyInstances(c, ri->sentinels);
+    } else if (!strcasecmp(c->argv[1]->ptr, "myid") && c->argc == 2) {
+        /* SENTINEL MYID */
+        addReplyBulkCBuffer(c, sentinel.myid, CONFIG_RUN_ID_SIZE);
+    } else if (!strcasecmp(c->argv[1]->ptr, "get-master-addr-by-name") ||
+               !strcasecmp(c->argv[1]->ptr, "get-master-addr-by-name")) {
+        /* SENTINEL GET-MASTER-ADDR-BY-NAME <master-name> */
+        sentinelValkeyInstance *ri;
+
+        if (c->argc != 3) goto numargserr;
+        ri = sentinelGetPrimary();
+        if (ri == NULL) {
+            addReplyNullArray(c);
+        } else {
+            sentinelAddr *addr = sentinelGetCurrentPrimaryAddress(ri);
+
+            addReplyArrayLen(c, 2);
+            addReplyBulkCString(c, announceSentinelAddr(addr));
+            addReplyBulkLongLong(c, addr->port);
+        }
+    } else if (!strcasecmp(c->argv[1]->ptr, "ckquorum")) {
+        /* SENTINEL CKQUORUM <name> */
+        if (c->argc != 3) goto numargserr;
+        addReplySds(c, sdscatfmt(sdsempty(), "+OK 1 usable Sentinels. Quorum and failover authorization "
+                                             "can be reached\r\n"));
+    } else if (!strcasecmp(c->argv[1]->ptr, "info-cache")) {
+        /* SENTINEL INFO-CACHE <name> */
+        if (c->argc < 2) goto numargserr;
+        mstime_t now = mstime();
+
+        /* Create an ad-hoc dictionary type so that we can iterate
+         * a dictionary composed of just the primary groups the user
+         * requested. */
+        dictType copy_keeper = instancesDictType;
+        copy_keeper.valDestructor = NULL;
+        dict *primaries_local = sentinel.primaries;
+        if (c->argc > 2) {
+            primaries_local = dictCreate(&copy_keeper);
+
+            for (int i = 2; i < c->argc; i++) {
+                sentinelValkeyInstance *ri;
+                ri = sentinelGetPrimaryByName(c->argv[i]->ptr);
+                if (!ri) continue; /* ignore non-existing names */
+                dictAdd(primaries_local, ri->name, ri);
+            }
+        }
+
+        /* Reply format:
+         *   1.) primary name
+         *   2.) 1.) info from primary
+         *       2.) info from replica
+         *       ...
+         *   3.) other primary name
+         *   ...
+         */
+        addReplyArrayLen(c, dictSize(primaries_local) * 2);
+
+        dictIterator *di;
+        dictEntry *de;
+        di = dictGetIterator(primaries_local);
+        while ((de = dictNext(di)) != NULL) {
+            sentinelValkeyInstance *ri = dictGetVal(de);
+            addReplyBulkCBuffer(c, ri->name, strlen(ri->name));
+            addReplyArrayLen(c, dictSize(ri->replicas) + 1); /* +1 for self */
+            addReplyArrayLen(c, 2);
+            addReplyLongLong(c, ri->info_refresh ? (now - ri->info_refresh) : 0);
+            if (ri->info)
+                addReplyBulkCBuffer(c, ri->info, sdslen(ri->info));
+            else
+                addReplyNull(c);
+
+            dictIterator *sdi;
+            dictEntry *sde;
+            sdi = dictGetIterator(ri->replicas);
+            while ((sde = dictNext(sdi)) != NULL) {
+                sentinelValkeyInstance *sri = dictGetVal(sde);
+                addReplyArrayLen(c, 2);
+                addReplyLongLong(c, ri->info_refresh ? (now - sri->info_refresh) : 0);
+                if (sri->info)
+                    addReplyBulkCBuffer(c, sri->info, sdslen(sri->info));
+                else
+                    addReplyNull(c);
+            }
+            dictReleaseIterator(sdi);
+        }
+        dictReleaseIterator(di);
+        if (primaries_local != sentinel.primaries) dictRelease(primaries_local);
+    } else {
+        addReplySubcommandSyntaxError(c);
+    }
+    return;
+
+numargserr:
+    addReplyErrorArity(c);
+}
+
+void addInfoSectionsToDict(dict *section_dict, char **sections);
+
+/* SENTINEL INFO [section] */
+void sentinelInfoCommand(client *c) {
+    char *sentinel_sections[] = {"server", "clients", "cpu", "stats", "sentinel", NULL};
+    int sec_all = 0, sec_everything = 0;
+    static dict *cached_all_info_sections = NULL;
+
+    /* Get requested section list. */
+    dict *sections_dict = genInfoSectionDict(c->argv + 1, c->argc - 1, sentinel_sections, &sec_all, &sec_everything);
+
+    /* Purge unsupported sections from the requested ones. */
+    dictEntry *de;
+    dictIterator *di = dictGetSafeIterator(sections_dict);
+    while ((de = dictNext(di)) != NULL) {
+        int i;
+        sds sec = dictGetKey(de);
+        for (i = 0; sentinel_sections[i]; i++)
+            if (!strcasecmp(sentinel_sections[i], sec)) break;
+        /* section not found? remove it */
+        if (!sentinel_sections[i]) dictDelete(sections_dict, sec);
+    }
+    dictReleaseIterator(di);
+
+    /* Insert explicit all sections (don't pass these vars to genValkeyInfoString) */
+    if (sec_all || sec_everything) {
+        releaseInfoSectionDict(sections_dict);
+        /* We cache this dict as an optimization. */
+        if (!cached_all_info_sections) {
+            cached_all_info_sections = dictCreate(&stringSetDictType);
+            addInfoSectionsToDict(cached_all_info_sections, sentinel_sections);
+        }
+        sections_dict = cached_all_info_sections;
+    }
+
+    sds info = genValkeyInfoString(sections_dict, 0, 0);
+    if (sec_all || (dictFind(sections_dict, "sentinel") != NULL)) {
+        dictIterator *di;
+        dictEntry *de;
+        int primary_id = 0;
+
+        if (sdslen(info) != 0) info = sdscat(info, "\r\n");
+        info = sdscatprintf(info,
+                            "# Sentinel\r\n"
+                            "sentinel_primaries:%lu\r\n"
+                            "sentinel_tilt:%d\r\n"
+                            "sentinel_tilt_since_seconds:%jd\r\n"
+                            "sentinel_running_scripts:%d\r\n"
+                            "sentinel_scripts_queue_length:%ld\r\n"
+                            "sentinel_simulate_failure_flags:%lu\r\n",
+                            dictSize(sentinel.primaries), sentinel.tilt,
+                            sentinel.tilt ? (intmax_t)((mstime() - sentinel.tilt_start_time) / 1000) : -1,
+                            sentinel.running_scripts, 0L, sentinel.simfailure_flags);
+
+        di = dictGetIterator(sentinel.primaries);
+        while ((de = dictNext(di)) != NULL) {
+            sentinelValkeyInstance *ri = dictGetVal(de);
+            char *status = "ok";
+
+            if (ri->flags & SRI_O_DOWN)
+                status = "odown";
+            else if (ri->flags & SRI_S_DOWN)
+                status = "sdown";
+            info = sdscatprintf(info,
+                                "master%d:name=%s,status=%s,address=%s:%d,"
+                                "slaves=%lu,sentinels=%lu\r\n",
+                                primary_id++, ri->name, status, announceSentinelAddr(ri->addr), ri->addr->port,
+                                dictSize(ri->replicas), dictSize(ri->sentinels) + 1);
+        }
+        dictReleaseIterator(di);
+    }
+    if (sections_dict != cached_all_info_sections) releaseInfoSectionDict(sections_dict);
+    addReplyBulkSds(c, info);
+}
+
+/* Implements Sentinel version of the ROLE command. The output is
+ * "sentinel" and the list of currently monitored primary names. */
+void sentinelRoleCommand(client *c) {
+    dictIterator *di;
+    dictEntry *de;
+
+    addReplyArrayLen(c, 2);
+    addReplyBulkCBuffer(c, "sentinel", 8);
+    addReplyArrayLen(c, dictSize(sentinel.primaries));
+
+    di = dictGetIterator(sentinel.primaries);
+    while ((de = dictNext(di)) != NULL) {
+        sentinelValkeyInstance *ri = dictGetVal(de);
+
+        addReplyBulkCString(c, ri->name);
+    }
+    dictReleaseIterator(di);
+}
+
+/* Drop any publish message */
+void sentinelPublishCommand(client *c) {
+    addReplyError(c, "No pub/sub messages support in this instance.");
+}
+
+void sentinelTimer(void) {
+    /* just do nothing */
+}
diff --git a/src/server.c b/src/server.c
index 83ae716d7..864592ba0 100644
--- a/src/server.c
+++ b/src/server.c
@@ -6693,6 +6693,8 @@ int checkForSentinelMode(int argc, char **argv, char *exec_name) {
     /* valkey may install symlinks like redis-sentinel -> valkey-sentinel. */
     if (strstr(exec_name, "redis-sentinel") != NULL) return 1;
 
+    if (strstr(exec_name, "valkey-senticache") != NULL) return 1;
+
     for (int j = 1; j < argc; j++)
         if (!strcmp(argv[j], "--sentinel")) return 1;
     return 0;
diff --git a/tests/instances.tcl b/tests/instances.tcl
index 5cc96b0ed..4ff12cfb5 100644
--- a/tests/instances.tcl
+++ b/tests/instances.tcl
@@ -26,10 +26,12 @@ set ::dont_clean 0
 set ::simulate_error 0
 set ::failed 0
 set ::sentinel_instances {}
+set ::senticache_instances {}
 set ::valkey_instances {}
 set ::global_config {}
 set ::sentinel_base_port 20000
 set ::valkey_base_port 30000
+set ::senticache_base_port 40000
 set ::valkey_port_count 1024
 set ::host "127.0.0.1"
 set ::leaked_fds_file [file normalize "tmp/leaked_fds.txt"]
@@ -53,6 +55,8 @@ proc exec_instance {type dirname cfgfile} {
         set prgname valkey-server
     } elseif {$type eq "sentinel"} {
         set prgname valkey-sentinel
+    } elseif {$type eq "senticache"} {
+        set prgname valkey-senticache
     } else {
         error "Unknown instance type."
     }
@@ -546,6 +550,21 @@ proc S {n args} {
     [dict get $s link] {*}$args
 }
 
+# Senticache call helper
+proc SC {args} {
+    set s [lindex $::senticache_instances 0]
+    [dict get $s link] {*}$args
+}
+
+# Senticache get client
+proc SCc {} {
+    set s [lindex $::senticache_instances 0]
+    set port [dict get $s port]
+    set host [dict get $s host]
+    set client [valkey $host $port 1 $::tls]
+    return $client
+}
+
 # Returns a server instance by index.
 # Example:
 #     [Rn 0] info
diff --git a/tests/senticache/run.tcl b/tests/senticache/run.tcl
new file mode 100644
index 000000000..a5e20774b
--- /dev/null
+++ b/tests/senticache/run.tcl
@@ -0,0 +1,23 @@
+cd tests/senticache
+source ../instances.tcl
+
+set ::tlsdir "../../tls"
+
+proc main {} {
+    parse_options
+    if {$::leaked_fds_file != ""} {
+        set ::env(LEAKED_FDS_FILE) $::leaked_fds_file
+    }
+    spawn_instance senticache $::senticache_base_port 1 {
+    } "../tests/includes/senticache.conf"
+
+    run_tests
+    cleanup
+    end_tests
+}
+
+if {[catch main e]} {
+    puts $::errorInfo
+    cleanup
+    exit 1
+}
diff --git a/tests/senticache/tests/00-base.tcl b/tests/senticache/tests/00-base.tcl
new file mode 100644
index 000000000..a650d0604
--- /dev/null
+++ b/tests/senticache/tests/00-base.tcl
@@ -0,0 +1,110 @@
+source "../tests/includes/init-tests.tcl"
+
+if {$::simulate_error} {
+    test "This test will fail" {
+        fail "Simulated error"
+    }
+}
+
+test "Quorum is always reachable for anything" {
+    assert {[SC SENTINEL CKQUORUM 1] == "OK 1 usable Sentinels. Quorum and failover authorization can be reached"}
+}
+
+test "Initial master has invalid addr" {
+    SC SENTINEL CACHE-UPDATE mysecret master-name: initial
+    set addr [SC SENTINEL GET-MASTER-ADDR-BY-NAME some-random-name]
+    assert {[lindex $addr 0] == "127.0.0.1"}
+    assert {[lindex $addr 1] == 0}
+}
+
+test "Setting invalid master addr does not affect in-memory struct" {
+    catch {[SC SENTINEL CACHE-UPDATE mysecret master-addr: 127.0.0.2 70000]} err
+    assert_match "*Invalid port value: 70000*" $err
+    set addr [SC SENTINEL GET-MASTER-ADDR-BY-NAME some-random-name]
+    assert {[lindex $addr 0] == "127.0.0.1"}
+    assert {[lindex $addr 1] == 0}
+}
+
+test "Initial master addr set works" {
+    SC SENTINEL CACHE-UPDATE mysecret master-addr: 127.0.0.2 20001
+    set addr [SC SENTINEL GET-MASTER-ADDR-BY-NAME some-random-name]
+    assert {[lindex $addr 0] == "127.0.0.2"}
+    assert {[lindex $addr 1] == 20001}
+}
+
+test "Master spec update works" {
+    SC SENTINEL CACHE-UPDATE mysecret master-spec: testrunid 2 3 4
+    set spec [SC SENTINEL MASTER some-random-name]
+    assert_match "* runid testrunid *" $spec
+    assert_match "* quorum 2 *" $spec
+    assert_match "* parallel-syncs 3*" $spec
+    assert_match "* config-epoch 4 *" $spec
+}
+
+test "Adding master as replica fails" {
+    catch {[SC SENTINEL CACHE-UPDATE mysecret add-replica: 127.0.0.2 20001]} err
+    assert_match "*Addr 127.0.0.2:20001 is already assigned to master*" $err
+}
+
+test "Adding replica works" {
+    SC SENTINEL CACHE-UPDATE mysecret add-replica: 127.0.0.2 20002
+    set master_spec [SC SENTINEL MASTER some-random-name]
+    assert_match "* num-slaves 1 *" $master_spec
+    set replicas [SC SENTINEL SLAVES some-random-name]
+    assert_match "*name 127.0.0.2:20002 ip 127.0.0.2 port 20002*" $replicas
+}
+
+test "Replica spec update works" {
+    SC SENTINEL CACHE-UPDATE mysecret slave-spec: 127.0.0.2 20002 test-replica 1 2 3 127.0.0.2 20001 0 5
+    set replicas [SC SENTINEL SLAVES some-random-name]
+    assert_match "* runid test-replica *" $replicas
+    assert_match "* master-link-down-time 1 *" $replicas
+    assert_match "* slave-priority 2 *" $replicas
+    assert_match "* replica-announced 3*" $replicas
+    assert_match "* master-host 127.0.0.2 *" $replicas
+    assert_match "* master-port 20001 *" $replicas
+    assert_match "* master-link-status ok *" $replicas
+    assert_match "* slave-repl-offset 5 *" $replicas
+}
+
+test "Replica delete works" {
+    SC SENTINEL CACHE-UPDATE mysecret delete-replica: 127.0.0.2 20002
+    set master_spec [SC SENTINEL MASTER some-random-name]
+    assert_match "* num-slaves 0 *" $master_spec
+}
+
+test "Nonexistent replica delete works" {
+    SC SENTINEL CACHE-UPDATE mysecret delete-replica: 127.0.0.2 20003
+    set master_spec [SC SENTINEL MASTER some-random-name]
+    assert_match "* num-slaves 0 *" $master_spec
+}
+
+test "Adding other sentinel works" {
+    SC SENTINEL CACHE-UPDATE mysecret add-sentinel: some-other-sentinel some-other-runid 127.0.0.2 40001
+    set master_spec [SC SENTINEL MASTER some-random-name]
+    assert_match "* num-other-sentinels 1 *" $master_spec
+    set sentinels [SC SENTINEL SENTINELS some-random-name]
+    assert_match "*name some-other-sentinel ip 127.0.0.2 port 40001 runid some-other-runid*" $sentinels
+}
+
+test "Sentinel delete works" {
+    SC SENTINEL CACHE-UPDATE mysecret delete-sentinel: some-other-sentinel
+    set master_spec [SC SENTINEL MASTER some-random-name]
+    assert_match "* num-other-sentinels 0 *" $master_spec
+}
+
+test "Nonexistent sentinel delete works" {
+    SC SENTINEL CACHE-UPDATE mysecret delete-sentinel: this-sentinel-was-never-added
+    set master_spec [SC SENTINEL MASTER some-random-name]
+    assert_match "* num-other-sentinels 0 *" $master_spec
+}
+
+test "Failover emulation works" {
+    SC SENTINEL CACHE-UPDATE mysecret add-replica: 127.0.0.2 20002
+    SC SENTINEL CACHE-UPDATE mysecret master-addr: 127.0.0.2 20002
+    set addr [SC SENTINEL GET-MASTER-ADDR-BY-NAME some-random-name]
+    assert {[lindex $addr 0] == "127.0.0.2"}
+    assert {[lindex $addr 1] == 20002}
+    set master_spec [SC SENTINEL MASTER some-random-name]
+    assert_match "* num-slaves 0 *" $master_spec
+}
diff --git a/tests/senticache/tests/01-pubsub.tcl b/tests/senticache/tests/01-pubsub.tcl
new file mode 100644
index 000000000..21d50d8b9
--- /dev/null
+++ b/tests/senticache/tests/01-pubsub.tcl
@@ -0,0 +1,27 @@
+source "../tests/includes/init-tests.tcl"
+
+test "Adding replica emits +slave" {
+    set sclient [SCc]
+    assert_equal {1} [psubscribe $sclient {*}]
+    SC SENTINEL CACHE-UPDATE mysecret master-name: initial, master-addr: 127.0.0.3 20001, add-replica: 127.0.0.3 20002
+    assert_equal {pmessage * +slave {slave 127.0.0.3:20002 127.0.0.3 20002 @ initial 127.0.0.3 20001}} [$sclient read]
+    $sclient close
+}
+
+test "Adding sentinel emits +sentinel" {
+    set sclient [SCc]
+    assert_equal {1} [psubscribe $sclient {*}]
+    SC SENTINEL CACHE-UPDATE mysecret add-sentinel: some-other-sentinel some-other-runid 127.0.0.3 40001
+    assert_equal {pmessage * +sentinel {sentinel some-other-sentinel 127.0.0.3 40001 @ initial 127.0.0.3 20001}} [$sclient read]
+    $sclient close
+}
+
+test "Failover with replica emits +switch-master, failover-end and +slave" {
+    set sclient [SCc]
+    assert_equal {1} [psubscribe $sclient {*}]
+    SC SENTINEL CACHE-UPDATE mysecret master-addr: 127.0.0.3 20002, add-replica: 127.0.0.3 20001
+    assert_equal {pmessage * +switch-master {initial 127.0.0.3 20001 127.0.0.3 20002}} [$sclient read]
+    assert_equal {pmessage * failover-end {master initial 127.0.0.3 20002}} [$sclient read]
+    assert_equal {pmessage * +slave {slave 127.0.0.3:20001 127.0.0.3 20001 @ initial 127.0.0.3 20002}} [$sclient read]
+    $sclient close
+}
diff --git a/tests/senticache/tests/includes/init-tests.tcl b/tests/senticache/tests/includes/init-tests.tcl
new file mode 100644
index 000000000..fbc4eb66a
--- /dev/null
+++ b/tests/senticache/tests/includes/init-tests.tcl
@@ -0,0 +1,6 @@
+# Initialization tests -- most units will start including this.
+source "../tests/includes/utils.tcl"
+
+test "(init) Restart instance" {
+    restart_senticache_instance
+}
diff --git a/tests/senticache/tests/includes/senticache.conf b/tests/senticache/tests/includes/senticache.conf
new file mode 100644
index 000000000..e69de29bb
diff --git a/tests/senticache/tests/includes/utils.tcl b/tests/senticache/tests/includes/utils.tcl
new file mode 100644
index 000000000..87bf9e55d
--- /dev/null
+++ b/tests/senticache/tests/includes/utils.tcl
@@ -0,0 +1,4 @@
+proc restart_senticache_instance {} {
+    kill_instance senticache 0
+    restart_instance senticache 0
+}
diff --git a/tests/senticache/tmp/.gitignore b/tests/senticache/tmp/.gitignore
new file mode 100644
index 000000000..4944e0096
--- /dev/null
+++ b/tests/senticache/tmp/.gitignore
@@ -0,0 +1 @@
+senticache_*
diff --git a/tests/sentinel/tests/00-base.tcl b/tests/sentinel/tests/00-base.tcl
index 33e590ab5..4f766459e 100644
--- a/tests/sentinel/tests/00-base.tcl
+++ b/tests/sentinel/tests/00-base.tcl
@@ -82,7 +82,7 @@ test "Basic failover works if the primary is down" {
     kill_instance valkey $master_id
     foreach_sentinel_id id {
         S $id sentinel debug ping-period 500
-        S $id sentinel debug ask-period 500  
+        S $id sentinel debug ask-period 500
         wait_for_condition 1000 100 {
             [lindex [S $id SENTINEL GET-PRIMARY-ADDR-BY-NAME mymaster] 1] != $old_port
         } else {
-- 
2.49.0

